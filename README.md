# rdf-virtuoso: Ruby Virtuoso adapter for RDF.rb
The intent of this class is to act as an abstraction for clients wishing to connect and manipulate linked data stored in a Virtuoso Quad store.

## How?
RDF::Virtuoso::Repository builds on RDF.rb and is the main connection class built on top of APISmith to establish the read and write methods to a Virtuoso store SPARQL endpoint.
RDF::Virtuoso::Query extends RDF::Query and adds SPARQL 1.1. update methods (insert, delete, aggregates, etc.).

For examples on use, please read:
     ./spec/client_spec.rb 
and 
     ./spec/query_spec.rb 

### A simple example

This example assumes you have a local installation of Virtoso running at standard port 8890

#### Setup Repository connection connection with auth

    uri        = "http://localhost:8890/sparql"
    update_uri = "http://localhost:8890/sparql-auth"
    repo       = RDF::Virtuoso::Repository.new(uri, :update_uri => update_uri, :username => 'admin', :password => 'secret', :auth_method => 'digest')

:auth_method can be 'digest' or 'basic'. a repository connection without auth requires only uri

#### INSERT WHERE query example

    QUERY = RDF::Virtuoso::Query
    graph = RDF::URI.new("http://test.com")
    subject = RDF::URI.new("http://subject")

    query = QUERY.insert([subject, :p, "object"]).graph(graph).where([subject, :p, :o])
    result = repo.insert(query)

#### A count query example

New prefixes can either extend the RDF::Vocabulary class (best if you want to model yourself:

    module RDF
      class FOO < RDF::Vocabulary("http://purl.org/ontology/foo/");end
      class BAR < RDF::Vocabulary("http://bar.net#");end
    end

it can then be easily accessed by RDF superclass, eg. 

    RDF::FOO.Document
    => #<RDF::URI:0x4d273ec(http://purl.org/ontology/foo/Document)> 
    RDF::BAR.telescope
    => #<RDF::URI:0x4d294ee(http://bar.net#telescope)> 

or you can dynamically add RDF::Vocabulary objects

    foo = RDF::Vocabulary.new("http://purl.org/ontology/foo/")

    QUERY  = RDF::Virtuoso::Query
    graph  = RDF::URI.new("http://test.com")

    query  = QUERY.select.where([:s, foo.bar, :o]).count(:s).graph(graph)
    result = repo.select(query)
    
Results will be an array of RDF::Query::Solution that can be accessed by bindings or iterated

    count = result.first[:count].to_i

## Rails specifics
Working on a prototype Rails application for negotiating and manipulating linked data in an RDF store, I discovered the lack of a reasonably current library to bridge the gap between the fairly well-established, modular RDF.rb library and a Rails 3 application. I wanted to be able to manipulate RDF data in a convenient, ActiveRecord/ActiveModel way. It turned out to be fairly non-trivial to mimic true AR/AM behavior and this is more or less the groundwork and result of my experimentation. I now have a much better idea of how to proceed, I just need the time to really go deep into this.
An example prototype that exercises this library can be found here: https://github.com/digibib/booky

It must be stressed that this is still early days, with lots of refactoring and abstraction to be done, along with very specific functionality targeted at the prototype I've been working on. So anyone wanting a more generalized approach would be well served by waiting until I'm further along.

Essentially, a model in a Rails 3 app subclasses ActiveRDF::Model, which in itself includes the following modules: 
ActiveAttr::Model - https://github.com/cgriego/active_attr
ActiveModel::Dirty - http://api.rubyonrails.org/classes/ActiveModel/Dirty.html
ActiveRDF::Persistence - responsible for handling persistence, in this gem

In a nutshell:

ActiveRDF::Model provides common functionality for models along with some mixed-in 3rd-party modules

ActiveRDF::Persistence provides some of the functionality a Rails model may expect, along with some placeholder methods that are waiting for AR/Arel type implementations. All communication is done via the query language SPARQL, (version 1.1 as of this writing).

RDF::Virtuoso::Client provides a rudimentary connection class for interacting with a Virtuoso server. It is inspired by API Smith (https://github.com/filtersquad/api_smith) which has some nice features, such as a convenient way to specify a Parser class for a given mimetype. See RDF::Virtuoso::Parser for example, and the method RDF::Virtuoso::Client#api_get.

## Challenges
In no particular order:

* In RDF data, the equivalent of a primary key in a relational database is called the subject (part of each of a set of triples), which is represented by a URI which looks like an absolute URL. When Rails does its magic with routes and friends, it assumes by default that it's dealing with an Integer, which is fine for a relational database id column which is auto-generated by the RDBM, unique and very often an int. Under the covers, to_i is called on id. This does not work for URLs, obviously. Also, you can't just send unencoded URLs over the wire as part of a path in a route. Anyway, this whole issue needed to be solved quickly, so for now RDF subjects that are part of a path are encoded and then decoded before insertion.
* On the topic of unique ids, relational databases can be told to autogenerate unique primary keys on insert for you. Here, we have to use a library (UUID) to generate unique ids before insert. 
* On the whole, when dealing with RDF subjects, care has to be taken how they are constructed. They can end with either a forward-slash or a hash, followed by some unique identifier. Seems like the hash-notation is preferred if the data is ever to be be exported as turtle files (suffix ttl) and the unique identifier potentially starts with an integer. Whether that is a bug in the writer implementation is unclear, but better safe than sorry.
* An update in an RDF store is a so-called modify and consists of one or more delete statements followed by one or more insert statements. Meaning that when a triple has changed, the original has to be deleted before the modified triple is inserted. There is a potential for leaving the data in an inconsistent state if, for instance, the delete directive isn't constructed correctly and the insert is. Or vice versa. With ActiveRecord, database writes are automatically wrapped in transactions that will roll back the data on failure. This too needed to be implemented explicitly, as seen in ActiveRDF::Persistence#update_attributes, using the SimpleTransaction libray.

## Notes
The following classes are not yet in use or will probably disapper:

* ActiveRDF::AssociationReflection
* ActiveRDF::Exceptions
* ActiveRDF::Reflections


 
